# Seoul Fit Frontend 개발 가이드

_작성일: 2025년 8월 21일_  
_대상: 개발자 및 기여자_

---

## 📋 목차

- [개발 환경 설정](#개발-환경-설정)
- [프로젝트 구조 이해](#프로젝트-구조-이해)
- [개발 워크플로우](#개발-워크플로우)
- [코딩 표준](#코딩-표준)
- [테스트 가이드](#테스트-가이드)
- [성능 최적화](#성능-최적화)
- [디버깅 방법](#디버깅-방법)
- [배포 프로세스](#배포-프로세스)

---

## 🚀 개발 환경 설정

### 필수 도구

```bash
# Node.js 18+ 설치 확인
node --version  # v18.0.0+

# npm 9+ 설치 확인
npm --version   # 9.0.0+

# Git 설정 확인
git --version   # 2.30.0+
```

### VSCode 설정

권장 확장 프로그램:
```json
{
  "recommendations": [
    "bradlc.vscode-tailwindcss",
    "esbenp.prettier-vscode",
    "dbaeumer.vscode-eslint",
    "ms-vscode.vscode-typescript-next",
    "bradlc.vscode-tailwindcss",
    "formulahendry.auto-rename-tag"
  ]
}
```

### 환경 변수 설정

```bash
# .env.local 파일 생성
cp .env.example .env.local

# 필수 환경 변수
NEXT_PUBLIC_KAKAO_MAP_API_KEY=your_key_here
SEOUL_API_KEY=your_seoul_api_key
NEXT_PUBLIC_API_BASE_URL=http://localhost:8080
```

---

## 📁 프로젝트 구조 이해

### 핵심 디렉토리

```
seoul-fit-fe/
├── app/                    # Next.js App Router
│   ├── api/               # 서버사이드 API
│   ├── auth/              # 인증 페이지
│   └── globals.css        # 전역 스타일
├── components/            # React 컴포넌트
│   ├── auth/             # 인증 관련
│   ├── layout/           # 레이아웃
│   ├── map/              # 지도 관련
│   └── ui/               # 재사용 UI
├── hooks/                # 커스텀 훅
├── lib/                  # 유틸리티
├── services/             # API 서비스
├── store/                # 상태 관리
└── docs/                 # 문서
```

### 컴포넌트 계층

```typescript
// 컴포넌트 명명 규칙
components/
├── ui/                   # 기본 UI 컴포넌트
│   ├── Button.tsx       # 재사용 가능한 버튼
│   ├── Input.tsx        # 입력 컴포넌트
│   └── Modal.tsx        # 모달 컴포넌트
├── layout/              # 레이아웃 컴포넌트
│   ├── Header.tsx       # 헤더
│   ├── SideBar.tsx      # 사이드바
│   └── Footer.tsx       # 푸터
└── map/                 # 지도 관련 컴포넌트
    ├── MapContainer.tsx # 지도 컨테이너
    ├── MapView.tsx      # 지도 뷰
    └── MapControls.tsx  # 지도 컨트롤
```

---

## 🔄 개발 워크플로우

### 1. 기능 개발 프로세스

```bash
# 1. 최신 코드 동기화
git checkout main
git pull origin main

# 2. 기능 브랜치 생성
git checkout -b feature/facility-search

# 3. 개발 서버 시작
npm run dev

# 4. 코드 작성 및 테스트
npm run validate  # 품질 검사

# 5. 커밋 및 푸시
git add .
git commit -m "feat: add facility search functionality"
git push origin feature/facility-search
```

### 2. 코드 리뷰 프로세스

```markdown
## PR 체크리스트
- [ ] 기능이 정상 동작하는가?
- [ ] 테스트가 작성되었는가?
- [ ] 문서가 업데이트되었는가?
- [ ] 성능에 영향이 없는가?
- [ ] 접근성이 고려되었는가?
```

---

## 📝 코딩 표준

### TypeScript 규칙

```typescript
// ✅ 좋은 예시
interface FacilityProps {
  /** 시설 ID */
  id: string;
  /** 시설명 */
  name: string;
  /** 시설 위치 */
  location: {
    lat: number;
    lng: number;
  };
  /** 선택 핸들러 */
  onSelect?: (facility: Facility) => void;
}

export function FacilityCard({ id, name, location, onSelect }: FacilityProps) {
  const handleClick = useCallback(() => {
    onSelect?.({ id, name, location });
  }, [id, name, location, onSelect]);

  return (
    <div 
      className="p-4 border rounded-lg cursor-pointer hover:bg-gray-50"
      onClick={handleClick}
      role="button"
      tabIndex={0}
      aria-label={`${name} 시설 선택`}
    >
      <h3 className="font-semibold">{name}</h3>
      <p className="text-sm text-gray-600">
        위도: {location.lat}, 경도: {location.lng}
      </p>
    </div>
  );
}

// ❌ 피해야 할 예시
function BadComponent(props: any) {
  return <div onClick={() => console.log(props)}>{props.data}</div>;
}
```

### React 컴포넌트 패턴

```typescript
// 1. 컴포넌트 Props 인터페이스 정의
interface ComponentProps {
  // props 정의
}

// 2. 컴포넌트 함수 정의
export function Component({ prop1, prop2 }: ComponentProps) {
  // 3. 상태 및 훅 사용
  const [state, setState] = useState<StateType>(initialState);
  const customHook = useCustomHook();
  
  // 4. 이벤트 핸들러 정의
  const handleEvent = useCallback(() => {
    // 핸들러 로직
  }, [dependencies]);
  
  // 5. 부수 효과 처리
  useEffect(() => {
    // 부수 효과 로직
    return () => {
      // 정리 로직
    };
  }, [dependencies]);
  
  // 6. 렌더링
  return (
    <div>
      {/* JSX */}
    </div>
  );
}
```

### 커스텀 훅 패턴

```typescript
// 커스텀 훅 예시
export function useFacilities(location?: Location) {
  const [facilities, setFacilities] = useState<Facility[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchFacilities = useCallback(async (loc: Location) => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await facilityService.getFacilities(loc);
      setFacilities(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '알 수 없는 오류');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (location) {
      fetchFacilities(location);
    }
  }, [location, fetchFacilities]);

  return {
    facilities,
    loading,
    error,
    refetch: () => location && fetchFacilities(location),
  };
}
```

---

## 🧪 테스트 가이드

### 단위 테스트

```typescript
// __tests__/components/FacilityCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { FacilityCard } from '@/components/FacilityCard';

describe('FacilityCard', () => {
  const mockFacility = {
    id: '1',
    name: '테스트 시설',
    location: { lat: 37.5665, lng: 126.9780 }
  };

  it('시설 정보를 올바르게 표시한다', () => {
    render(<FacilityCard {...mockFacility} />);
    
    expect(screen.getByText('테스트 시설')).toBeInTheDocument();
    expect(screen.getByText(/위도: 37.5665/)).toBeInTheDocument();
  });

  it('클릭 시 onSelect 콜백을 호출한다', () => {
    const mockOnSelect = jest.fn();
    render(<FacilityCard {...mockFacility} onSelect={mockOnSelect} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(mockOnSelect).toHaveBeenCalledWith(mockFacility);
  });
});
```

### 통합 테스트

```typescript
// __tests__/hooks/useFacilities.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { useFacilities } from '@/hooks/useFacilities';
import * as facilityService from '@/services/facilities';

jest.mock('@/services/facilities');

describe('useFacilities', () => {
  it('위치가 제공되면 시설을 가져온다', async () => {
    const mockFacilities = [{ id: '1', name: '테스트 시설' }];
    jest.spyOn(facilityService, 'getFacilities').mockResolvedValue(mockFacilities);

    const { result } = renderHook(() => 
      useFacilities({ lat: 37.5665, lng: 126.9780 })
    );

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.facilities).toEqual(mockFacilities);
  });
});
```

---

## ⚡ 성능 최적화

### React 최적화

```typescript
// 1. React.memo 사용
export const FacilityList = React.memo(({ facilities }: Props) => {
  return (
    <div>
      {facilities.map(facility => (
        <FacilityCard key={facility.id} {...facility} />
      ))}
    </div>
  );
});

// 2. useCallback 최적화
const handleFacilitySelect = useCallback((facility: Facility) => {
  // 핸들러 로직
}, [/* 의존성 */]);

// 3. useMemo 최적화
const filteredFacilities = useMemo(() => {
  return facilities.filter(facility => 
    facility.category === selectedCategory
  );
}, [facilities, selectedCategory]);

// 4. 코드 분할
const LazyMapComponent = lazy(() => import('./MapComponent'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <LazyMapComponent />
    </Suspense>
  );
}
```

### 번들 최적화

```typescript
// next.config.ts
const nextConfig = {
  // 번들 분석
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        fs: false,
        net: false,
        tls: false,
      };
    }
    return config;
  },
  
  // 이미지 최적화
  images: {
    domains: ['example.com'],
    formats: ['image/webp', 'image/avif'],
  },
  
  // 압축
  compress: true,
};
```

---

## 🐛 디버깅 방법

### 개발 도구 활용

```typescript
// 1. React DevTools 사용
// 컴포넌트 상태 및 props 검사

// 2. 구조화된 로깅
const logger = {
  info: (message: string, data?: any) => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[INFO] ${message}`, data);
    }
  },
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${message}`, error);
  }
};

// 3. 성능 측정
function measurePerformance<T>(fn: () => T, label: string): T {
  const start = performance.now();
  const result = fn();
  const end = performance.now();
  console.log(`${label}: ${end - start}ms`);
  return result;
}
```

### 일반적인 문제 해결

```typescript
// 1. 무한 리렌더링 방지
useEffect(() => {
  // 의존성 배열을 정확히 지정
}, [dependency1, dependency2]);

// 2. 메모리 누수 방지
useEffect(() => {
  const timer = setTimeout(() => {
    // 타이머 로직
  }, 1000);

  return () => {
    clearTimeout(timer); // 정리 함수
  };
}, []);

// 3. 상태 업데이트 최적화
const [state, setState] = useState(initialState);

// 함수형 업데이트 사용
setState(prevState => ({
  ...prevState,
  newProperty: newValue
}));
```

---

## 🚀 배포 프로세스

### 프로덕션 빌드

```bash
# 1. 의존성 설치
npm ci

# 2. 타입 검사
npm run type-check

# 3. 린팅
npm run lint

# 4. 테스트
npm run test

# 5. 빌드
npm run build

# 6. 빌드 검증
npm run start
```

### 환경별 설정

```typescript
// 개발 환경
const isDevelopment = process.env.NODE_ENV === 'development';

// API URL 설정
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 
  (isDevelopment ? 'http://localhost:8080' : 'https://api.seoul-fit.com');

// 디버그 모드
const DEBUG_MODE = isDevelopment || process.env.DEBUG === 'true';
```

---

## 📚 추가 리소스

### 유용한 링크

- [Next.js 문서](https://nextjs.org/docs)
- [React 문서](https://react.dev/)
- [TypeScript 문서](https://www.typescriptlang.org/docs/)
- [TailwindCSS 문서](https://tailwindcss.com/docs)

### 커뮤니티

- [GitHub Discussions](https://github.com/seoul-fit/seoul-fit-fe/discussions)
- [이슈 트래커](https://github.com/seoul-fit/seoul-fit-fe/issues)

---

이 가이드를 따라 개발하면 일관되고 고품질의 코드를 작성할 수 있습니다. 질문이 있으시면 언제든지 이슈를 생성하거나 토론에 참여해 주세요!
